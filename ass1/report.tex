\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{graphicx} %package to manage images
\graphicspath{ {.} }
\newlist{steps}{enumerate}{1}
\setlist[steps, 1]{label = Step \arabic*:}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Sequences of given length where every element is more than or equal to twice of previous\\
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Sumit Kumar Sahu (IIT2019069)}
\IEEEauthorblockA{\textit{B.Tech Information Technology} \\
\textit{IIIT Allahabad}\\
}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Adelik Om Tyagi (IIT2019070)}
\IEEEauthorblockA{\textit{B.Tech Information Technology} \\
\textit{IIIT Allahabad}\\
}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}

\maketitle

\begin{abstract}
In this paper, we have devised 2 algorithms to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m, while optimizing time and space complexity. We have determined both the time, and the space complexity of our algorithm by illustrating through some graphs.
\end{abstract}

\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

\section{Introduction}
For finding the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m can be solved using recursion.
Recursion is the process of repeating items in a self-similar way. In programming languages, if a program allows you to call a function inside the same function, then it is called a recursive call of the function.
\newline
As we know wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming.
The idea is to simply store the results of sub-problems, so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial.
\newline
As per the given condition the n-th value of the sequence can be at most m. There can be two cases for n-th element.
\begin{enumerate}
\item If it is m, then the (n-1)th element is at most m/2. We recur for m/2 and n-1.
\item If it is not m, then it is at most m-1. We recur for (m-1) and n.
\end{enumerate}
The total number of sequences is the sum of the number of sequences including m and the number of sequences where m is not included. Thus the original problem of finding number of sequences of length n with max value m can be subdivided into independent sub-problems of finding number of sequences of length n with max value m-1 and number of sequences of length n-1 with max value m/2.

\section{ALGORITHM 1}

\subsection{ALGORITHM DESIGN}
\begin{enumerate}
\item Take input of integers n and m in variables n and m respectively.

\item Call for the solve function with parameters as n and m which will give the answer.

\item Solve function is using a recursive approach to find the answer.

\item Base cases for this function is when m becomes zero then we will return zero and also when n will become one then we will return m.

\item Create a new variable ret initialized with zero and looping from 1 to m and adding answers from 1 to m in ret by recursively calling the solve function for smaller input.

\item Return the value of ret which has the final answer.

\end{enumerate}

\subsection{ALGORITHM }

\textbf{Input:} N(length of sequence) and M(upper bound on sequence elements)

\textbf{Output:} Number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.

\textbf{Method:}

\begin{enumerate}
    \item call the solve function with parameters as n and m: solve(n,m);
    \item if $m<=0$ return 0
    \item if $n==1$ return m
    \item Declare and Initialise ret with 0.
    \item Loop the current element(i) of the sequence from 1 to m.
    \setlength{\itemindent}{+.5in}
    \item call the solve function with parameters n-1 and i/2. Add the returned value to ret
    \setlength{\itemindent}{0in}
	\item return ret;
	
\end{enumerate}


\subsection{APRIORI ANALYSIS }
\begin{center}
   \begin{tabular}{|c|c|c|c}
   \hline
   Step&Time&FreqBest&Freq \\
   \hline\hline
   Step1 & 1 & 1 &  1 \\
    \hline
   Step2 & 1 & 1 &  m$^{n}$\\
    \hline
   Step3 & 1 & 1 &  m$^{n}$\\
    \hline
   Step4 & 1 & 1 &  m$^{n}$\\
    \hline
  Step5 & 1 & 1 &  m$^{n}$\\
  \hline
  Step6 & 1 & 1 &  m$^{n}$\\
    \hline
    Step7 & 1 & 1 &  m$^{n}$ \\
    \hline
    \end{tabular} 
\end{center}
For Best Case
\newline
T$\Omega$ $\alpha$ 1*1+1*1+1*1+1*1+1*1+1*1+1*1
\newline
T$\Omega$ $\alpha$ 7
\newline
Thus, the best case time complexity is O(1) when n=1 OR m is non positive
\newline
For Worst Case
\newline
T$\Omega$ $\alpha$ 1*  m$^{n}$+1* m$^{n}$+1* m$^{n}$+1* m$^{n}$+1* m$^{n}$+1*  m$^{n}$+1* m$^{n}$
\newline
T$\Omega$ $\alpha$ 7* m$^{n}$
\newline
Clearly this equation will come out to be of the exponential form .
\newline
Thus , worst case time complexity is O( m$^{n}$)
\newline
Space complexity is O(1)
\newline
Time complexity â€“
\newline
Fix m=30 and vary n
\newline
\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   n & Time \\
   \hline\hline
    1 & 0.3 \\
    \hline
    2 & 0.9 \\
    \hline
    3 & 270 \\
    \hline
    5 & 243000 \\
    \hline
    6 & 7290000 \\
    \hline
    7 & 218700000 \\
    \hline
    \end{tabular} 
\end{center}
\includegraphics[width=8cm,height=8cm]{Figureone1.png}
\newline
Fix n=3 and vary m
\newline
\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 0.03 \\
    \hline
    2 & 20000 \\
    \hline
    3 & 40000 \\
    \hline
    5 & 60000 \\
    \hline
    6 & 80000 \\
    \hline
    7 & 120000 \\
    \hline
    8 & 140000 \\
    \hline
    10 & 160000 \\
    \hline
    12 & 180000 \\
    \hline
    \end{tabular} 
\end{center}
\includegraphics[width=8cm,height=8cm]{Figureone2.png}
\newline

\subsection{APOSTERIORI ANALYSIS }

First we Fix M=300 and vary N from 1 to 7
\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 0 \\
    \hline
    2 & 3 \\
    \hline
    3 & 224 \\
    \hline
    4 & 4493 \\
    \hline
    5 & 34892 \\
    \hline
    6 & 112558 \\
    \hline
    7 & 246904 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_1.png}

Now we Fix n=4 and vary M from 1 to 100

\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 0 \\
    \hline
    16 & 0 \\
    \hline
    30 & 3 \\
    \hline
    40 & 7 \\
    \hline
    50 & 13 \\
    \hline
    60 & 22 \\
    \hline
    100 & 99 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_2.png}


From these two graphs we can conclude that complexity is exponential in 'n' and polynomial in 'm'

\subsection{TIME COMPLEXITY}

Worst case : O($m^{n}$)

Best case  : $\Omega$(1) when n=1

\section{ALGORITHM 2}

\subsection{ALGORITHM DESIGN}

\begin{enumerate}
\item Take input of integers n and m in variables n and m respectively. 
\item Call for the isZero function with parameters as n and m which will check whether the answer exists or not. 
\item If $n>=60$ then return true as our algorithm works till long long int.Also if m $<$ 2 to the power n-1 then we cannot have the sequence of length n having max value upto m so return true. And if the return value is true or it does not exist then we exit after printing 0.
\item Else using we create a vector of vectors mem of n+1 rows and m+1 columns and initializing it to -1.
\item Call the solve function with parameters n,m,mem which uses recursion with memoization (Dynamic Programming) to find the answer.
\item Base cases for this function is when the isZero function with n,m as parameters return true then return zero and also when n will become one then we will return m.
\item Check if the value at n,m in the mem vector is not -1 then we return mem[n][m] as answer for this n,m is stored in the previous call of the solve function on n,m.
\item As per the given condition the n-th value of the sequence can be at most m. There can be two cases for n-th element.
\newline
   (i) If it is m, then the (n-1)th element is at most m/2. We recur for m/2 and n-1.
   \newline
   (ii) If it is not m, then it is at most m-1. We recur for (m-1) and n.
   \newline
 So we recursive call for the solve function with parameters  n,m-1,mem and n-1,m/2,mem and add the return values from both and store it in mem[n][m] so if further this n,m is called then we can  return its value without computation as we have stored.
\item Final answer is returned from the solve function and displayed.


\end{enumerate}

\subsection{ALGORITHM }

\textbf{Input:} N(length of sequence) and M(upper bound on sequence elements)

\textbf{Output:} Number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.

\textbf{Method of isZero(n,m)}

\begin{enumerate}
    \item if $n>=60$ return false;
    \item if $m<2^{n-1}$ return false;
\end{enumerate}

\textbf{Method of solve(n,m)}

\begin{enumerate}
    \item Check if the answer is 0. If found 0 return.
    \item if n==1 return m
    \item if mem[n][m]!=-1 return mem[n][m]
    \item Call solve for n,m-1 and n-1,m/2 and assign their sum in mem[n][m]
	
\end{enumerate}

\subsection{APRIORI ANALYSIS }
\begin{center}
   \begin{tabular}{|c|c|c|c}
   \hline
   Step&Time&FreqBest&Freq \\
   \hline\hline
    Step1&1&1&1 \\
    \hline
   Step2&1&1&1\\
    \hline
   Step3&1&1&n*m\\
    \hline
   Step4&1&1&n*m\\
    \hline
  Step5&1&0&n*m\\
    \hline
    Step6&2&0&n*m-m \\
    \hline
    \end{tabular} 
\end{center}
For Best Case
\newline
T$\Omega$ $\alpha$ 1*1+1*1+1*1+1*1+1*0+2*0
\newline
T$\Omega$ $\alpha$ 4
\newline
Thus, the best case time complexity is O(1) when n=1
\newline
For Worst Case
\newline
T$\Omega$ $\alpha$ 1*1+1*1+1*(n*m)+1*(n*m)+1*(n*m)+1*(n*m-m)
\newline
T$\Omega$ $\alpha$ 3+4*(n*m)-m
\newline
Clearly this equation will come out to be of the quadratic form .
\newline
Thus , worst case time complexity is O(n*m)
\newline
Space complexity is O(n*m)
\newline
Time complexity â€“
\newline
Fix n=6 and vary m
\newline
\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   m & Time \\
   \hline\hline
    1 & 0.01 \\
    \hline
    70 & 4.2 \\
    \hline
    700 & 42 \\
    \hline
    7000 & 420 \\
    \hline
    10000 & 600 \\
    \hline
    12000 & 720 \\
    \hline
    \end{tabular} 
\end{center}
\includegraphics[width=8cm,height=8cm]{Figuresec1.png}
\newline
Fix m=1000000 and vary n
\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 10000 \\
    \hline
    2 & 20000 \\
    \hline
    4 & 40000 \\
    \hline
    6 & 60000 \\
    \hline
    8 & 80000 \\
    \hline
    12& 120000 \\
    \hline
    14 & 140000 \\
    \hline
    16 & 160000 \\
    \hline
    18 & 180000 \\
    \hline
    20 & 0.01 \\
    \hline
    22 & 0.01 \\
    \hline
    24 & 0.01 \\
    \hline
    25 & 0.01 \\
    \hline
    28 & 0.01 \\
    \hline
    \end{tabular} 
\end{center}
\includegraphics[width=8cm,height=8cm]{Figuresec_2.png}
\newline

\subsection{APOSTERIORI ANALYSIS }

First we Fix N=10 and vary M from 1 to 100000

\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   M & Time \\
   \hline\hline
    1 & 0 \\
    \hline
    2001 & 180 \\
    \hline
    9001 & 224 \\
    \hline
    43001 & 4282 \\
    \hline
    78001 & 7857 \\
    \hline
    88001 & 8701 \\
    \hline
    99001 & 9704 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_3.png}

From above graph we can conclude that complexity is linear in 'm'.

Now we Fix m=1000000 and vary n from 1 to 100

\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 12205 \\
    \hline
    16 & 130887 \\
    \hline
    30 & 0 \\
    \hline
    40 & 0 \\
    \hline
    50 & 0 \\
    \hline
    60 & 0 \\
    \hline
    100 & 0 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_4.png}

In above graph complexity first increases linearly with 'n', but as 'n' increases the isZero() function calculates the answer in O(1) and graph gets merged with the x-axis. 

\subsection{TIME COMPLEXITY}

Worst case : O(min(n,$log_2$($MAX_M$))*m)

Best case  : $\Omega$(1) when answer is 0

\section*{CONCLUSION}

Our second algorithm which we solved by divide and conquer is more efficient because unlike recursive solution  it is storing the result of every function call and hence is not making same function calls multiple times. It has a time complexity and space complexity of O(min(n,log$_{2}$(M))*m).

\begin{thebibliography}{00}
\bibitem{b1} CP-Algorithms : Divide and Conquer Algorithm.
\bibitem{b2} GFG : Sequences of given length where every element is more than or equal to twice of previous.
\end{thebibliography}

\end{document}
