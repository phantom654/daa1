\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{graphicx} %package to manage images
\graphicspath{ {.} }
\newlist{steps}{enumerate}{1}
\setlist[steps, 1]{label = Step \arabic*:}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Sequences of given length where every element is more than or equal to twice of previous\\
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Sumit Kumar Sahu (IIT2019069)}
\IEEEauthorblockA{\textit{B.Tech Information Technology} \\
\textit{IIIT Allahabad}\\
}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Adelik Om Tyagi (IIT2019070)}
\IEEEauthorblockA{\textit{B.Tech Information Technology} \\
\textit{IIIT Allahabad}\\
}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}

\maketitle

\begin{abstract}
In this paper, we have devised 2 algorithms to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m, while optimizing time and space complexity. We have determined both the time, and the space complexity of our algorithm by illustrating through some graphs.
\end{abstract}

\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

\section{Introduction}
For finding the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m can be solved using recursion.
Recursion is the process of repeating items in a self-similar way. In programming languages, if a program allows you to call a function inside the same function, then it is called a recursive call of the function.
\newline
As we know wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming.
The idea is to simply store the results of sub-problems, so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial.
\newline
As per the given condition the n-th value of the sequence can be at most m. There can be two cases for n-th element.
\begin{enumerate}
\item If it is m, then the (n-1)th element is at most m/2. We recur for m/2 and n-1.
\item If it is not m, then it is at most m-1. We recur for (m-1) and n.
\end{enumerate}
The total number of sequences is the sum of the number of sequences including m and the number of sequences where m is not included. Thus the original problem of finding number of sequences of length n with max value m can be subdivided into independent sub-problems of finding number of sequences of length n with max value m-1 and number of sequences of length n-1 with max value m/2.

\section{ALGORITHM 1}

\subsection{ALGORITHM DESIGN}
\begin{enumerate}
\item Take input of integers n and m in variables n and m respectively.

\item Call for the solve function with parameters as n and m which will give the answer.

\item Solve function is using a recursive approach to find the answer.

\item Base cases for this function is when m becomes zero then we will return zero and also when n will become one then we will return m.

\item Create a new variable ret initialized with zero and looping from 1 to m and adding answers from 1 to m in ret by recursively calling the solve function for smaller input.

\item Return the value of ret which has the final answer.

\end{enumerate}

\subsection{ALGORITHM }

\textbf{Input:} N(length of sequence) and M(upper bound on sequence elements)

\textbf{Output:} Number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.

\textbf{Method:}

\begin{enumerate}
    \item call the solve function with parameters as n and m: solve(n,m);
    \item if $m<=0$ return 0
    \item if $n==1$ return m
    \item Declare and Initialise ret with 0.
    \item Loop the current element(i) of the sequence from 1 to m.
    \setlength{\itemindent}{+.5in}
    \item call the solve function with parameters n-1 and i/2. Add the returned value to ret
    \setlength{\itemindent}{0in}
	\item return ret;
	
\end{enumerate}


\subsection{APRIORI ANALYSIS }

This document is a model and instructions for \LaTeX.
Please observe the conference page limits. 

\subsection{APOSTERIORI ANALYSIS }

First we Fix M=300 and vary N from 1 to 7
\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 0 \\
    \hline
    2 & 3 \\
    \hline
    3 & 224 \\
    \hline
    4 & 4493 \\
    \hline
    5 & 34892 \\
    \hline
    6 & 112558 \\
    \hline
    7 & 246904 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_1.png}

Now we Fix n=4 and vary M from 1 to 100

\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 0 \\
    \hline
    16 & 0 \\
    \hline
    30 & 3 \\
    \hline
    40 & 7 \\
    \hline
    50 & 13 \\
    \hline
    60 & 22 \\
    \hline
    100 & 99 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_2.png}


From these two graphs we can conclude that complexity is exponential in 'n' and polynomial in 'm'

\subsection{TIME COMPLEXITY}

Worst case : O($m^{n}$)

Best case  : $\Omega$(1) when n=1

\section{ALGORITHM 2}

\subsection{ALGORITHM DESIGN}

\begin{enumerate}
\item Take input of integers n and m in variables n and m respectively. 
\item Call for the isZero function with parameters as n and m which will check whether the answer exists or not. 
\item If $n>=60$ then return true as our algorithm works till long long int.Also if m < 2 to the power n-1 then we cannot have the sequence of length n having max value upto m so return true. And if the return value is true or it does not exist then we exit after printing 0.
\item Else using we create a vector of vectors mem of n+1 rows and m+1 columns and initializing it to -1.
\item Call the solve function with parameters n,m,mem which uses recursion with memoization (Dynamic Programming) to find the answer.
\item Base cases for this function is when the isZero function with n,m as parameters return true then return zero and also when n will become one then we will return m.
\item Check if the value at n,m in the mem vector is not -1 then we return mem[n][m] as answer for this n,m is stored in the previous call of the solve function on n,m.
\item As per the given condition the n-th value of the sequence can be at most m. There can be two cases for n-th element.
\newline
   (i) If it is m, then the (n-1)th element is at most m/2. We recur for m/2 and n-1.
   \newline
   (ii) If it is not m, then it is at most m-1. We recur for (m-1) and n.
   \newline
 So we recursive call for the solve function with parameters  n,m-1,mem and n-1,m/2,mem and add the return values from both and store it in mem[n][m] so if further this n,m is called then we can  return its value without computation as we have stored.
\item Final answer is returned from the solve function and displayed.


\end{enumerate}

\subsection{ALGORITHM }

\textbf{Input:} N(length of sequence) and M(upper bound on sequence elements)

\textbf{Output:} Number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.

\textbf{Method of isZero(n,m)}

\begin{enumerate}
    \item if $n>=60$ return false;
    \item if $m<2^{n-1}$ return false;
\end{enumerate}

\textbf{Method of solve(n,m)}

\begin{enumerate}
    \item Check if the answer is 0. If found 0 return.
    \item if n==1 return m
    \item if mem[n][m]!=-1 return mem[n][m]
    \item Call solve for n,m-1 and n-1,m/2 and assign their sum in mem[n][m]
	
\end{enumerate}

\subsection{APRIORI ANALYSIS }

This document is a model and instructions for \LaTeX.
Please observe the conference page limits. 

\subsection{APOSTERIORI ANALYSIS }

First we Fix N=10 and vary M from 1 to 100000

\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   M & Time \\
   \hline\hline
    1 & 0 \\
    \hline
    2001 & 180 \\
    \hline
    9001 & 224 \\
    \hline
    43001 & 4282 \\
    \hline
    78001 & 7857 \\
    \hline
    88001 & 8701 \\
    \hline
    99001 & 9704 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_3.png}

From above graph we can conclude that complexity is linear in 'm'.

Now we Fix m=1000000 and vary n from 1 to 100

\begin{center}
   \begin{tabular}{|c|c|}
   \hline
   N & Time \\
   \hline\hline
    1 & 12205 \\
    \hline
    16 & 130887 \\
    \hline
    30 & 0 \\
    \hline
    40 & 0 \\
    \hline
    50 & 0 \\
    \hline
    60 & 0 \\
    \hline
    100 & 0 \\
    \hline
    \end{tabular} 
\end{center}

\includegraphics[width=8cm, height=8cm]{Figure_4.png}

In above graph complexity first increases linearly with 'n', but as 'n' increases the isZero() function calculates the answer in O(1) and graph gets merged with the x-axis. 

\subsection{TIME COMPLEXITY}

Worst case : O(min(n,$log_2$($MAX_M$))*m)

Best case  : $\Omega$(1) when answer is 0

\section*{CONCLUSION}

The preferred spelling of the word ``acknowledgment'' in America is without 
an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. 
G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor 
acknowledgments in the unnumbered footnote on the first page.

\begin{thebibliography}{00}
\bibitem{b1} CP-Algorithms : Divide and Conquer Algorithm.
\bibitem{b2} GFG : Sequences of given length where every element is more than or equal to twice of previous.
\end{thebibliography}

\end{document}
